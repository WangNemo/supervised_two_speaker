function [masks, snr] = snrEst(sig,params)
%Function to estimate the IBM and the SNRs
%Input
%   sig -   The signal. Can be the filename (in MSWAV format), or the actual
%           signal itself. The signal is assumed to be sampled at 16 KHz.
%   params - A structure with multiple fields
%       params.ebm          - The estimated mask or the filename containing the
%                               mask. If this parameter is sent, the mask is not estimated.
%       params.ebm_ke       - The mask estimated using CASA strategy (Ke's 2011
%                               paper). Could be the filename or the mask itself.
%       params.tandemRoot   - The file root for the outputs generated by the
%                               tandem algorithm (Hu 2010). The algorithm will append .128.mask.dat
%                               or .128.pitch.dat to this root to read the tandem outputs.
%       params.broadband    - This field should exist for broadband SNR estimation
%       params.subband      - This field should exist for subband SNR estimation
%       params.tmpDir       - The directory to store temporary files. If
%                               not passed, the current directory will be
%                               used instead. Ideal to set it somewhere on
%                               your /scratch directory.
%Output
%     masks - The estimated masks. Contains c128 and c64 fields for 128
%               channel and 64 channel estimated IBMs, respectively.
%     snr - The estimated SNRs. May contain the following fields
%         snr.filtered    - The filtered SNR
%         snr.broadband   - The broadband SNR
%         snr.subband     - The subband SNRs
%

%% Set all the necessary parameters
if nargin < 2
    params = struct;
end
if isfield(params,'ebm') %The estimated binary mask
    ebm = params.ebm;
end
% if isfield(params,'tandemRoot') %The tandem root to read output files
%     tandemRoot = params.tandemRoot;
% end
% if isfield(params,'ebm_ke') %Mask estimated by Ke's algo, or any CASA based mask
%     ebm_ke = params.ebm_ke;
% end
if isfield(params,'tmpDir') %set temp working directory here
    tmpDir = params.tmpDir;
else
    tmpDir = pwd;
end

%Set an initial dummy output
snr.readme = 'Estimated SNR values';
masks.readme = 'Estiamted IBMs';

% %Necessary libraries
% path(path,'/home1/narayaar/Toolboxes/fileaccess/');
% path(path,'/home1/narayaar/Toolboxes/CASA/');
% path(path,'/home1/narayaar/Toolboxes/Noise_Tracker_V1/');
% path(path,'/home1/narayaar/Toolboxes/HKmss/');

%Parameters
wavnorm = 3.276797651191444e+004; %To convert mswav files to integer format
fs = 16000; %Sampling rate
numChan = 128; %Number of channels for SNR estimation
% numChan_subBand = 64; %Number of subbands for subband SNR estimation
fRange = [50 8000]; %The frequency range
winLength = 20*fs/1000; %20 msec window

% %For Ke's algorithm - Parameters to create pitch Mask
% crossChannelThresh=0.985; 
% evCrossChannelThresh=0.985;
  
%% Hendricks parameters
if ~exist('ebm','var') %Only if the estimated masks is not sent as a parameter
    fprintf(1,'\nPass a binary mask\n');
    return;
end

%% IBM Estimation
if ischar(sig)
    sig = round(wavread(sig)*wavnorm);
end

if exist('ebm','var')
    if ischar(ebm)
        ebm = load(ebm);
    end
end
% else
%     if ~exist('ebm_ke','var')
%         % Use tandem to get voiced mask
%         if ~exist('tandemRoot','var');
%             tandemRoot = [tmpDir, filesep, 'tmpSig_' datestr(now,'yyyymmdd_HHMMSS')];
%             dlmwrite([tandemRoot,'.val'],round(sig),'delimiter',' ');
%             cmd = sprintf('! . /home1/narayaar/Toolboxes/Tandem/tandem.sh %d %d %s %s',fs,numChan,[tandemRoot,'.val'],tandemRoot);
%             eval(cmd);
%             
%             if ~exist([tandemRoot,'.' num2str(numChan) '.mask.dat'],'file')
%                 fprintf(1,'\nTandem failed. Try running tandem on windows or re-create the mixture signal.\n');
%                 exit(1);
%             end
%         end
%         
%         %Use Ke to get unvoiced mask
%         nFrames = floor(length(sig)/(winLength/2));
%         % Start by estimating the periodic mask based on (envelope) auto-correlatiosn
%         corrDir = [tmpDir,'/Corr_' num2str(round(rand*1000)) '_' datestr(now,'yyyymmdd_HHMMSS') filesep];
%         asciiCur = [tandemRoot,'.val'];
%         if ~exist(asciiCur,'file')
%             dlmwrite([tandemRoot,'.val'],round(sig),'delimiter',' ');
%         end
%         mkdir(corrDir);
%         getCorrelogram(asciiCur,corrDir,numChan);
%         clear clgm evClgm;
%         for frNum = 1:nFrames
%             corrFile = [corrDir 'frame' '-' num2str(frNum)];
%             if ~exist(corrFile,'file')
%                 break;
%             end;
%             clgm(:,:,frNum) = matread(corrFile);
%             enCorrFile = [corrDir 'frame' 'Ev-' num2str(frNum)];
%             evClgm(:,:,frNum) = matread(enCorrFile);
%         end
%         clgm = clgm(:,1:end-1,:);
%         evClgm = evClgm(:,1:end-1,:);
%         
%         %Calculate the voiced mask - voiced speech + harmonic noise using the cross correlogram
%         pitchMask = pitchLabel(clgm,evClgm,crossChannelThresh,evCrossChannelThresh,1);
%         if size(pitchMask,1) < nFrames %Note pMask has its dimensions flipped as compared to ibms.
%             pitchMask = [pitchMask(1,:);pitchMask];
%         end
%         matwrite(pitchMask,[tandemRoot,'.' num2str(numChan) '.pMask']);
%         rmdir(corrDir,'s');
%         
%         [VMask,pitch] = processMask([tandemRoot,'.' num2str(numChan) '.mask.dat'],[tandemRoot,'.' num2str(numChan) '.pitch.dat'],numChan);
%         [ebm_ke,UMask] = createMask_Ke(sig,VMask',[tandemRoot,'.' num2str(numChan) '.pMask'],numChan);
%         UMask = UMask';
%         ebm_ke = ebm_ke';
%         
%         if ~isfield(params,'tandemRoot')
%             delete([tandemRoot,'.val']);
%             delete([tandemRoot,'.' num2str(numChan) '.mask.dat']);
%             delete([tandemRoot,'.' num2str(numChan) '.pitch.dat']);
%             delete([tandemRoot,'.' num2str(numChan) '.pMask']);
%         end
%     else
%         if ischar(ebm_ke)
%             ebm_ke = load(ebm_ke)>0;
%         end
%     end
%     
%     %Hendricks estimates
%     [hendricks.dft.snr,cleantmp.psd,noisetmp.psd] = ...
%         hendricks_snr_estimator(sig,options,g_dft,g_mag,g_mag2);
%     
%     hebm = pow_gt*cleantmp.psd >= LC_ratio_ke_hendricks*pow_gt*noisetmp.psd;
%     raw_segments = segmentation(hebm',0);
%     segments = refineSegs(raw_segments,3,3,0,0,0);
%     hebm = (poolsegments(segments))'; clear raw_segments segments;
%     
%     %Expand if needed,
%     if size(hebm,2) < size(ebm_ke,2)
%         hebm = [hebm(:,1),hebm];
%     end
%     
%     % The final estimated mask
%     ebm = (ebm_ke + hebm) > 0;
% end
% masks.c128 = ebm; %Assumes numChan is 128.

%% Broadband and filtered SNR
if isfield(params,'broadband')
    engy = cochleagram(gammatoneSNR(sig,numChan,fRange,fs),winLength);
    
    target = sum(sum(engy .* ebm));
    noise = sum(sum(engy)) - target;
    snr.filtered = 10*log10(target) - 10*log10(noise);
    
    ccgmEn = sum(sum(engy));
    diffEn = 2*sum(sig.^2) - ccgmEn;
    k=10^(snr.filtered/10);
    cleanEn = (k/(1+k))*ccgmEn;
    snr.broadband = 10*log10(cleanEn/(ccgmEn-cleanEn+max(0,diffEn)));
end

%% Channel SNRs, across 64 channels
% if isfield(params,'subband')
%     mix_cgm = cochleagram(gammatone(sig,numChan_subBand,fRange,fs),winLength); %Note that normalized gammatone is not used anymore, to match typical CASA processing
%     ebm_64 = (ebm(1:2:end,:)+ebm(2:2:end,:)+[ebm(3:2:end,:);ebm(end,:)])>1.9; %Sub-sample the mask to 64 channels in a slightly better way
%     target_engy = sum(mix_cgm .* ebm_64,2);
%     noise_engy = sum(mix_cgm,2) - target_engy;
%     snr.subband = 10*log10(target_engy+realmin) - 10*log10(noise_engy+realmin);
%     % Limit SNR estimates to the rage [-20, 30]
%     snr.subband(snr.subband<-20)=-20;
%     snr.subband(snr.subband>30)=30;
%     clear target_engy noise_engy ibm;
%     masks.c64 = ebm_64;
% end
end